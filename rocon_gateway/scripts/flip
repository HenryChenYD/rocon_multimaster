#!/usr/bin/env python
#       
# License: BSD
#   https://raw.github.com/robotics-in-concert/rocon_multimaster/master/rocon_gateway/LICENSE 
#

##############################################################################
# Imports
##############################################################################

import sys
import argparse
import re
import roslib 
roslib.load_manifest('rocon_gateway')
import rospy
import rocon_gateway
import gateway_msgs
import rocon_gateway.console as console
import rocon_gateway.utils as utils

##############################################################################
# Functions
##############################################################################

def print_debug(msg):
    console.pretty_print("%s\n"%msg, console.green)

def print_warning(msg):
    console.pretty_print("%s\n"%msg, console.yellow)

def print_error(msg):
    console.pretty_print("%s\n"%msg, console.red)
    
def parse_arguments():
    parser = argparse.ArgumentParser(description='Flip a local connection to a remote gateway')
    parser.add_argument('-g', '--gateway', default=None, help='name/regex of the target remote gateway')
    parser.add_argument('-n', '--name', default=None, help='name/regex of the local connection')
    parser.add_argument('-t', '--type', default=None, help="type of the local connection (publisher, subscriber, service, action_client, action_server, 'any'")
    parser.add_argument('-d', '--node', default=None, help="node of the local connection (can be 'any')")
    parser.add_argument('--cancel', action='store_true', help='cancel the flip')
    args = parser.parse_args()
    if args.cancel:
        action_text = "cancelling"
    else:
        action_text = "flipping"
    return args

def resolve_local_gateway():
    console.pretty_print("Local Gateway\n",console.bold)
    master = rocon_gateway.LocalMaster()
    gateway_namespace = master.findGatewayNamespace()
    if not gateway_namespace:
        print_error("  Not found - did you start it?")
        raise rocon_gateway.GatewayError("Cannot proceed without a local gateway, aborting")
    print("  Namespace: %s"%gateway_namespace)
    return gateway_namespace

def resolve_remote_gateways(gateway, gateway_namespace):
    console.pretty_print("Remote Gateway\n",console.bold)
    '''
      @raise rocon_gateway.GatewayError: if no remote gateways or no matching gateways available. 
    '''
    remote_gateways = []
    remote_gateway_info = rospy.ServiceProxy(gateway_namespace+'/remote_gateway_info', gateway_msgs.srv.RemoteGatewayInfo)
    req = gateway_msgs.srv.RemoteGatewayInfoRequest()
    req.gateways = []
    resp = remote_gateway_info(req)
    if len(resp.gateways) == 0:
        print_error("  None found.")
        raise rocon_gateway.GatewayError("Cannot proceed without a remote gateway target, aborting.")
    if gateway:
        for remote_gateway in resp.gateways:
            if re.match(gateway,remote_gateway.name):
                if remote_gateway.firewall:
                    print_warning("  Remote gateway target matched, but it is firewalling flips [%s][%s]\n"%(gateway,remote_gateway))
                else:
                    remote_gateways.append(remote_gateway.name)
        if not remote_gateways:
            print_error("  No valid (matching) targets [%s]%s."%(gateway,str([remote_gateway.name for remote_gateway in resp.gateways])))
            raise rocon_gateway.GatewayError("Cannot proceed without a valid remote gateway target")
    else:
        index = 0;
        max_index = len(resp.gateways) - 1
        if max_index == 0:
            print_debug("  Automatically selecting %s (only one visible)"%resp.gateways[0].name)
            remote_gateways.append(resp.gateways[0].name)
        else:
            print("  Select a gateway from the list below")
            for remote_gateway in resp.gateways:
                print("    " + str(index) + ") " + remote_gateway.name)
                index +=1
            chosen_index = raw_input("  Enter a value [0-%s]: "%str(max_index))
            remote_gateways.append(resp.gateways[int(chosen_index)].name)
    print("  Targets:")
    for remote_gateway in remote_gateways: # This should always be populated by here, otherwise its a bug!
        print("    %s"%remote_gateway)
    return remote_gateways

def resolve_connections(name, type, node):
    console.pretty_print("Connections\n",console.bold)
    # Connection Type
    connection_type = None
    if not type:
        index = 0;
        print("  Select a type from the list below")
        for connection_type_string in utils.connection_type_strings_list:
            print("    " + str(index) + ") " + connection_type_string)
            index +=1
        chosen_index = raw_input("  Enter a value [0-4]: ")
        connection_type = utils.connection_types_list[int(chosen_index)]
    else:
        match = [utils.connection_types_list[index] for index, type_string in enumerate(utils.connection_type_strings_list) if type_string == type]
        if not match:
            print_error("  Invalid type string [%s]"%type)
            raise rocon_gateway.GatewayError("Cannot proceed without a valid type string")
        connection_type = match[0]
    # Connections
    master = rocon_gateway.LocalMaster()
    connections = master.getConnectionState()[connection_type]
    if len(connections) == 0:
        print_error("  No local %s connections found."%connection_type)
        raise rocon_gateway.GatewayError("Cannot proceed without a remote gateway target, aborting.")
    rules = []
    if name:
        for connection in connections:
            if re.match(name, connection.rule.name):
                if (node and (node == connection.rule.node)) or not node:
                    rules.append(connection.rule)
    else:
        index = 0;
        max_index = len(connections) - 1
        if max_index == 0:
            print_debug("  Automatically selecting %s (only one available)"%connections[0].rule.name)
            rules.append(connections[0].rule)
        else:
            print("  Select a type from the list below")
            for connection in connections:
                print("    " + str(index) + ") " + connection.rule.name + "-" + connection.rule.node)
                index +=1
            chosen_index = raw_input("  Enter a value [0-%s]: "%str(max_index))
            rules.append(connections[int(chosen_index)].rule)
    for rule in rules:
        print("  Connection:")
        print("    Name: %s"%rule.name)
        print("    Type: %s"%rule.type)
        print("    Node: %s"%rule.node)
        
    return rules

def flip_rules(gateway_namespace, remote_gateways, rules, cancel_flag):
    console.pretty_print("Flip Interface\n",console.bold)
    flip_service = rospy.ServiceProxy(gateway_namespace+'/flip',gateway_msgs.srv.Remote)
    for remote_gateway in remote_gateways:
        req = gateway_msgs.srv.RemoteRequest()
        for rule in rules:
            req.cancel = cancel_flag
            # check that it isn't already flipped, or not there to be cancelled
            req.remotes.append(gateway_msgs.msg.RemoteRule(remote_gateway,rule))
        print("  Flip Request:")
        print("    Gateway : %s"%remote_gateway)
        print("    Cancel: %s"%cancel_flag)
        for rule in rules:
            print("      Rule : [%s,%s,%s]"%(rule.name,rule.type,rule.node))
        confirm = raw_input("  Confirm (y/n): ")
        if confirm == 'y':
            console.pretty_print("    Flip request sent!\n", console.magenta)
            resp = flip_service(req)

##############################################################################
# Main
##############################################################################

if __name__ == '__main__':
    
    rospy.init_node('flip')
    args = parse_arguments()
    gateway_namespace = None
    remote_gateways = None
    
    try:
        gateway_namespace = resolve_local_gateway()
        remote_gateways = resolve_remote_gateways(args.gateway, gateway_namespace)
    except rocon_gateway.GatewayError, unused_e:
        print("Aborting")
        sys.exit(1)
    rules = resolve_connections(args.name, args.type, args.node)
    flip_rules(gateway_namespace, remote_gateways, rules, args.cancel)

